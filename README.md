<h1>PVK File Import/Export Wizard</h1>

<p>PVK File Import/Export Wizard is a small Windows application that allows you to import and export your cryptographic private keys. You can import an .SPC (or .CER, .P7B) /.PVK file pair into your system or export the private key of a certificate into a .PVK file.</p>

<p>While importing an .SPC/.PVK file pair, the application examines the certificates contained in the .SPC file and determines the most appropriate certificate stores to put them. The certificate associated with the private key is always saved to the personal certificate store. The other certificates in the chain are placed in the enterprise, intermediate, or root certificate stores depending on the key usage type and the signature.</p>

<p>While exporting a private key always leave the "Enable strong encryption" option checked if you do not plan to import the key to a system older than Windows 2000 with Service Pack 2. If unchecked the application generates a 40 bit file encryption key, which is considerably weaker than the one (128 bit) generated by default.</p>

<h2>Using the PVK import/export routines</h2>
                                                    
<p>PVK is a file format invented by Microsoft to import/export cryptographic private keys securely.</p> 

<p>The PVK File Import/Export library provides a programmatic way to work with PVK files. The API has only two routines; <code>BlgPvkExport</code> and <code>BlgPvkImport</code>.</p> 

<pre>BOOL
BlgPvkImport(
   IN HCRYPTPROV Provider,
   IN PCWSTR FileName,
   IN PCSTR Password OPTIONAL,
   IN DWORD Flags OPTIONAL,
   OUT HCRYPTKEY *Key
   );

BOOL
BlgPvkExport(
   IN HCRYPTPROV Provider,
   IN DWORD KeySpec,
   IN PCWSTR FileName,
   IN PCSTR Password OPTIONAL,
   IN DWORD Flags OPTIONAL
   );</pre>

<p>The signatures are self explanatory. However, the <code>Flags</code> parameter requires a brief explanation.</p>

<p>The <code>Flags</code> parameter of the <code>BlgPvkImport</code> routine can be zero or a combination of <code>CRYPT_EXPORTABLE</code> and <code>CRYPT_USER_PROTECTED</code> flags defined in the Microsoft CryptoAPI header file. For their descriptions please refer to the MSDN documentation. Also note that you must release the key that you have received via the <code>Key</code> parameter by calling the <code>CryptDestroyKey</code> routine.</p>

<p>The <code>Flags</code> parameter of the <code>BlgPvkExport</code> routine has only one valid flag; <code>BLG_PVKEXPORT_FLAG_WEAK</code>. It causes the routine to always use 40 bit RC4 encryption to encrypt the exported private key. By default, if the cryptographic service provider supports, 128 bit RC4 encryption is used. Specify this flag only if you plan to import your key to a key container owned by a CSP that does not support the 128 bit RC4 algorithm.</p>

<p>Below are two samples demonstrating the use of the routines. The first program selects the certificate with the subject name "ACME Software", retrieves its private key container, and exports the private key to the acme.pvk file. The second one opens or creates a key container, named ACMEContainer, and calls the <code>BlgPvkImport</code> routine specifying the name of the PVK file, acme.pvk, and the password of the file to import the private key.</p>

<pre>#include &lt;windows.h&gt;
#include &lt;blgpvk.h&gt;

INT main(INT argc, PCWSTR *argv)
{
   BOOL IsOk = FALSE;
   HCERTSTORE CertStore = NULL;
   PCCERT_CONTEXT CertContext = NULL;
   HCRYPTPROV Provider;
   DWORD KeySpec;
   BOOL FreeProv = FALSE;

   CertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM, 
                             PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, 
                             0, 
                             CERT_SYSTEM_STORE_CURRENT_USER, L"My");

   if (!CertStore)
   {
      goto Leave;
   }

   CertContext = CertFindCertificateInStore(CertStore, 
                                            PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, 
                                            0,
                                            CERT_FIND_SUBJECT_STR, L"ACME Software", NULL);

   if (!CertContext)
   {
      goto Leave;
   }

   if (!CryptAcquireCertificatePrivateKey(CertContext, 
                                         CRYPT_ACQUIRE_USE_PROV_INFO_FLAG, 
                                         NULL, 
                                         &amp;Provider, &amp;KeySpec, &amp;FreeProv))
   {
      goto Leave;
   }

   IsOk = BlgPvkExport(Provider, KeySpec, L"C:\\acme.pvk", "p@sswor9!", 0);

Leave:
   if(FreeProv)
   {
      CryptReleaseContext(Provider, 0);
   }

   if(CertContext)
   {
      CertFreeCertificateContext(CertContext);
   }

   if(CertStore)
   {
      CertCloseStore(CertStore, 0);
   }

   return IsOk ? 0 : -1;
}</pre>

<pre>#include &lt;windows.h&gt;
#include &lt;blgpvk.h&gt;

INT main(INT argc, PCWSTR *argv)
{
   HCRYPTPROV Provider;
   HCRYPTKEY Key;

   if(!CryptAcquireContext(&amp;Provider, L"ACMEContainer", MS_ENHANCED_PROV, PROV_RSA_FULL, 0))
   {
      if(GetLastError() == NTE_BAD_KEYSET)
      {
         if(!CryptAcquireContext(&amp;Provider, 
                                 L"ACMEContainer", 
                                 MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET))
         {
            return -1;
         }
      }
      else
      {
         return -1;
      }
   }

   if(!BlgPvkImport(Provider, L"C:\\acme.pvk", "p@sswor9!", 0, &amp;Key))
   {
      CryptReleaseContext(Provider, 0);

      return -1;
   }

   CryptDestroyKey(Key);

   CryptReleaseContext(Provider, 0);

   return 0;
}</pre>  